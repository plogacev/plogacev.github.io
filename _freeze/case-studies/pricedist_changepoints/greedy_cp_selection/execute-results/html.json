{
  "hash": "11715cfad0a40dc3e5f6ec31ad3a5340",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bayesian Changepoint Detection on Price Histograms\"\nauthor: \"Pavel Logaƒçev\"\ndate: \"r Sys.Date()\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-tools: true\n    df-print: paged\nengine: knitr\neditor: visual\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Rcpp)\nsource(\"./source/data_generation.r\")\nsource(\"./source/greedy_cp_selection.r\")\nRcpp::sourceCpp(\"./source/greedy_cp_selection.cpp\")\n```\n:::\n\n\n## Summary\n\nThis notebook demonstrates a Bayesian changepoint detection algorithm for histogram-valued time series. It is based on a greedy search tailored for transactional price data with varying pricing regimes.\n\n-   Each day's price distribution is modeled via discretized histograms.\n-   The changepoint configuration is selected via greedy MAP estimation.\n-   In the future, parameters may be obtained by means of sampling instead of greedy search. (For instance, using RcppSMC or a custom sampler, e.g., MH).\n\n## Modeling Approach\n\nWe model the price distribution of a product as a histogram over discrete price points, because in B2C scenarios, only a few specifc prices are available at any given time. Some customer groups may be offered a discount, while most purchase at the list price. Modeling daily means or medians may lose the multimodal structure that matters most for detecting pricing regimes. Histogram-valued preserve the full distributional shape, making it possible to detect subtle regime shifts such as list price changes or availability of discounts. The method is useful for detecting changes in pricing regimes, such as list price changes, promotions, or changes in the availability of discounts.\n\nEach day is represented by a histogram over discrete price points. The time series is transformed into a histogram-valued sequence, represented as a matrix of counts. We assume that pricing follows distinct *pricing regimes*, each associated with a different price distribution. Changes in pricing regime occur when the pricing of a product undergoes a meaningful change ‚Äî such as list price changes, promotions, or changes in the availability of discounts. Changepoints are defined as time indices where the underlying price distribution regime changes, leading to a change in relative frequency of price points.\n\n### Data Format\n\nThe synthetic data used in this notebook simulates 800 days of pricing activity, segmented into 10 regimes characterized by different list prices, discounts, and discount availability\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\nsegments <- data.frame(\n             start_day = c(1,  90, 250, 300, 400, 500, 550, 600, 700, 750),\n            list_price = c(5,    6,   6,   6,   6, 5.5, 5.5, 5.5, 7, 7),\n        discount_price = c(4,    4,   5,   5,   5, 4.5, 4.5, 4.5, 2, 2),\n   discount_percentage = c(.25, .1,  .1, .25,  .5, .01, .03, .15,.3, .4)\n)\n\nn_days <- 800\nlambda_qty <- 20\ndf <- generate_transaction_prices(segments, n_days, lambda_qty, seed = 123)\nhist <- compute_price_histogram(df)\nactual_changepoints <- segments$start_day[-1]-0.5\n\nknitr::kable(segments, caption = \"Price Regimes Overview\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in attr(x, \"align\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in attr(x, \"format\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n```\n\n\n:::\n\n::: {.cell-output-display}\n\n\nTable: Price Regimes Overview\n\n| start_day| list_price| discount_price| discount_percentage|\n|---------:|----------:|--------------:|-------------------:|\n|         1|        5.0|            4.0|                0.25|\n|        90|        6.0|            4.0|                0.10|\n|       250|        6.0|            5.0|                0.10|\n|       300|        6.0|            5.0|                0.25|\n|       400|        6.0|            5.0|                0.50|\n|       500|        5.5|            4.5|                0.01|\n|       550|        5.5|            4.5|                0.03|\n|       600|        5.5|            4.5|                0.15|\n|       700|        7.0|            2.0|                0.30|\n|       750|        7.0|            2.0|                0.40|\n\n\n:::\n:::\n\n\nThe plot below shows the synthetic data set, with the actual changepoints marked with dashed vertical lines. This is the dataset we'll use to test the segmentation algorithm.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_price <- hist$df %>% rename(quantity = qty) %>%  filter(quantity > 0) %>%\n    ggplot(aes(day, price)) + geom_point(aes(size=quantity, alpha = quantity)) + \n    geom_vline( data = data.frame(x = actual_changepoints, changepoint = \"actual\"),\n                aes(xintercept = x, color = changepoint), linetype = \"dashed\") + theme_bw() +\n    theme(legend.position = \"top\") \n\nprint(p_price)\n```\n\n::: {.cell-output-display}\n![](greedy_cp_selection_files/figure-html/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n### Model Structure\n\n#### Segmentation\n\nWe define a segmentation of a histogram-valued time series $h$ of length $T$ as a vector $z \\in \\{0, 1\\}^{T-1}$, where $z_t=1$ indicates a changepoint between indices $t$ and $t+1$, and $0$ indicates its absence. From the index vector $z$, we can derive a segmentation in the form of $\\mathcal{S}(z)$, i.e., a set of all segment intervals $[t_1, t_2]$.\n\nThe model is intended to select a segmentation $z$ that best balances *(i)* goodness-of-fit (how well the empirical histograms are explained within segments) with *(ii)* model simplicity (how many changepoints are included). The balance is governed by the regularizing parameter $\\lambda$, which is selected by optimizing the posterior likelihood over it.\n\nThe posterior over a changepoint configurations $z$ is assumed to be:\n\n$$\np(z \\mid \\mathbf{n}, \\lambda) \\propto p(\\mathbf{n} \\mid z) \\cdot p(z) \\cdot p(\\lambda)\n$$\n\n### Likelihood\n\nThe data likelihood is computed as the product of likelihoods of the segments defined by the segmentation $\\mathcal{S}(z)$, where $\\mathbf{n}_{[t_1, t_2]}$ stands for the histogram over the interval $[t_1, t_2]$.\n\n$$\np(\\mathbf{n} \\mid z) = \\prod_{(t_1, t_2) \\in \\mathcal{S}(z)} p(\\mathbf{n}_{[t_1, t_2]})\\text{,}\n$$\n\n```{=html}\n<!--\n$$\n\\mathbf{n_{[t_1, t_2]}} = \\sum_{t = t_1}^{t_2} \\mathbf{h}_t\n$$\n-->\n```\n\nThe likelihood of a segment $\\mathbf{n}_{[t_1, t_2]}$ is set to it (regularized) maximum likelihood estimate ... (explain more) ..., where $\\hat{p}_i$ is the (regularized) maximum likelihood estimate of the relative frequencies of the different price points. This corresponds to using the **maximum likelihood estimate** of the multinomial probabilities within each segment. Although technically this is not fully Bayesian (since we're not integrating over latent parameters), it can be viewed as an empirical Bayes approximation.\n\n$$\np(\\mathbf{n}_{[t_1, t_2]}) = \\sum_{i=1}^{K} (\\hat{p}_i)^{n_i}\n$$\n\nIn computing $\\hat{p}_i$, we smooth each bin count with a small constant $\\epsilon$ to prevent division by zero.\n\n$$\n\\hat{p}_i = \\frac{n_i + \\epsilon}{\\sum_j (n_j + \\epsilon)}\n$$\n\n### Prior\n\nWe place a Bernoulli prior on each potential changepoint, to penalize excessive complexity: small $\\lambda$ values encourage fewer changepoints, favoring parsimony. In consequence, the model selects the segmentation $z$ that best balances goodness-of-fit (how well the empirical histograms are explained within segments) with model simplicity (how many changepoints are included). The balance is governed by $\\lambda$.\n\n$$\nz_t \\sim \\text{Bernoulli}(\\lambda)\n$$\n\n## Estimation\n\nTo estimate the changepoint configuration $z$, we use a greedy forward search:\n\n1.  Start with no changepoints.\n2.  Iteratively add the changepoint that most increases the penalized posterior.\n3.  Stop when no further improvement is possible.\n\nThis process is repeated for different values of $\\lambda$, and the $\\lambda$ value that maximizes the resulting posterior is selected using one-dimensional optimization (`optimize()` in R).\n\n## Implementation\n\nThis project implements a greedy changepoint detection algorithm for time series of price histograms. The codebase consists of three components:\n\n-   A data generator that simulates daily transaction-level price data under piecewise constant pricing regimes (`generate_transaction_prices()`).\n-   A transformation step that maps transactional data into a histogram matrix (`compute_price_histogram()`).\n-   A C++ backend that performs fast log-likelihood evaluation and greedy changepoint selection via Rcpp.\n\n## Changepoint Detection Results\n\nIn the present example, the algorithm detects the same number changepoints, and the estimates ones, are largely fairly close to the simulated ones. A formal evaluation is pending. It stands to reason that the accuracy of changepoint identification will depend on the similarity between adjacent segments, as well as segment length.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopt_res <- locate_optimal_changepoints( hist$histogram, max_lambda = 0.3 )\ndetected_changepoints <- which(opt_res$changepoints) - 0.5\n\nknitr::kable(t(actual_changepoints), caption = \"Original Changepoints\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in attr(x, \"align\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in attr(x, \"format\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n```\n\n\n:::\n\n::: {.cell-output-display}\n\n\nTable: Original Changepoints\n\n|     |      |      |      |      |      |      |      |      |\n|----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|\n| 89.5| 249.5| 299.5| 399.5| 499.5| 549.5| 599.5| 699.5| 749.5|\n\n\n:::\n\n```{.r .cell-code}\nknitr::kable(t(detected_changepoints), caption = \"Detected Changepoints\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in attr(x, \"align\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\nWarning in attr(x, \"align\"): 'xfun::attr()' is deprecated.\nUse 'xfun::attr2()' instead.\nSee help(\"Deprecated\")\n```\n\n\n:::\n\n::: {.cell-output-display}\n\n\nTable: Detected Changepoints\n\n|     |      |      |      |      |      |      |      |      |\n|----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|\n| 88.5| 249.5| 294.5| 398.5| 498.5| 558.5| 598.5| 698.5| 737.5|\n\n\n:::\n:::\n\n\nThe plot below illustrates the results vis a vis the simulation assumptions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_price +\n      geom_vline( data = data.frame(x = detected_changepoints, changepoint = \"detected\"),\n                  aes(xintercept = x, color = changepoint), linetype = \"dashed\") +\n      scale_color_manual(name = \"changepoint\", values = c(\"detected\" = \"blue\", \"actual\" = \"red\"),\n                        guide = guide_legend(override.aes = list( linetype = \"solid\", size = 1))\n                        )\n```\n\n::: {.cell-output-display}\n![](greedy_cp_selection_files/figure-html/thumbnail-image-1.png){width=960}\n:::\n:::\n\n\n## Limitations\n\n-   The algorithm is designed to detect even small changes in average price if they are sufficiently frequent.\n-   In the present version, it cannot deal with days with no sales, and may possibly identify them as a new pricing regime, thus zero-sales days have to be excluded before running it.\n-   The algorithm is not designed to deal with overlapping price regimes.\n\n## Repository\n\nAll source code is available here:\\\nüëâ <https://github.com/plogacev/case_studies/tree/main/pricedist_changepoints>\n\n```{=html}\n<pre><code class=\"language-cpp\">\ndouble log1m_exp(double x)\n{\nif (x >= 0.0) stop(\"log1m_exp is undefined for x >= 0\");\n...\n}\n</code></pre>\n```\n",
    "supporting": [
      "greedy_cp_selection_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}